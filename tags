!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD	request.h	37;"	d
ALPHA	generate.h	12;"	d
ARRIVAL_CONSTANT	generate.h	14;"	d
ARRIVAL_EXPONENTIAL	generate.h	15;"	d
CAS	request.h	/^  char CAS[8];$/;"	m	struct:request_header
CAS	response.h	/^  char CAS[8];$/;"	m	struct:response_header
CDF_VALUES	generate.h	11;"	d
CLIENT_H	loader.h	5;"	d
CONFIG_H	config.h	5;"	d
CONN_H	conn.h	3;"	d
DEBUG_READ_WRITE	util.h	13;"	d
DEL	request.h	36;"	d
GENERATE_H	generate.h	3;"	d
GET	request.h	31;"	d
GETQ	request.h	33;"	d
INCR	request.h	35;"	d
INCR_FIX_QUEUE_SIZE	worker.h	18;"	d
INC_DCR_NON_NUM	response.h	14;"	d
INVALID_ARGUMENT	response.h	12;"	d
ITEM_NOT_STORED	response.h	13;"	d
KEY_EXISTS	response.h	10;"	d
KEY_NOT_FOUND	response.h	9;"	d
LOWER_MASK	mt.c	51;"	d	file:
LOWER_MASK	mt19937p.c	37;"	d	file:
M	mt.c	48;"	d	file:
M	mt19937p.c	34;"	d	file:
MAGIC2	magic2_breakpoint.h	4;"	d
MAGIC_REQUEST	request.h	9;"	d
MAGIC_RESPONSE	request.h	10;"	d
MATRIX_A	mt.c	49;"	d	file:
MATRIX_A	mt19937p.c	35;"	d	file:
MATRIX_A	mt19937p.h	22;"	d
MAX_DATAGRAM_SIZE	response.c	34;"	d	file:
MAX_KEY_LENGTH	request.h	41;"	d
MAX_KEY_SIZE	generate.h	10;"	d
MAX_SERVERS	config.h	12;"	d
MAX_VALUE_LENGTH	request.h	42;"	d
MEMCACHED_PORT	conn.h	6;"	d
MEMCACHE_HEADER_SIZE	request.h	40;"	d
MT19937P	mt19937p.h	20;"	d
MT_H	mt.h	3;"	d
N	mt.c	47;"	d	file:
N	mt19937p.c	33;"	d	file:
N	mt19937p.h	23;"	d
NO_ERROR	response.h	8;"	d
OP_ADD	request.h	18;"	d
OP_DEL	request.h	17;"	d
OP_GET	request.h	13;"	d
OP_GETQ	request.h	15;"	d
OP_INCR	request.h	16;"	d
OP_REP	request.h	19;"	d
OP_SET	request.h	14;"	d
OP_STAT	request.h	12;"	d
OUT_OF_MEMORY	response.h	16;"	d
QUEUE_SIZE	worker.h	17;"	d
REP	request.h	38;"	d
REQUEST_H	request.h	3;"	d
RESPONSE_H	response.h	2;"	d
SET	request.h	32;"	d
STAT	request.h	34;"	d
STATS_H	stats.h	8;"	d
TCP_MODE	config.h	10;"	d
TEMPERING_MASK_B	mt19937p.c	40;"	d	file:
TEMPERING_MASK_C	mt19937p.c	41;"	d	file:
TEMPERING_SHIFT_L	mt19937p.c	45;"	d	file:
TEMPERING_SHIFT_S	mt19937p.c	43;"	d	file:
TEMPERING_SHIFT_T	mt19937p.c	44;"	d	file:
TEMPERING_SHIFT_U	mt19937p.c	42;"	d	file:
TYPE_ADD	request.h	26;"	d
TYPE_DEL	request.h	25;"	d
TYPE_GET	request.h	21;"	d
TYPE_INCR	request.h	24;"	d
TYPE_MULTIGET	request.h	23;"	d
TYPE_REP	request.h	27;"	d
TYPE_SET	request.h	22;"	d
UDP_MODE	config.h	11;"	d
UNKNOWN_COMMAND	response.h	15;"	d
UPPER_MASK	mt.c	50;"	d	file:
UPPER_MASK	mt19937p.c	36;"	d	file:
UTIL_H	util.h	5;"	d
VALUE_TOO_LARGE	response.h	11;"	d
WORKER_H	worker.h	2;"	d
_magic2_breakpoint_h_	magic2_breakpoint.h	2;"	d
addSample	stats.c	/^void addSample(struct stat* stat, float value) {$/;"	f
adds	stats.h	/^  int adds;$/;"	m	struct:memcached_stats
arrival_distribution_type	config.h	/^  int arrival_distribution_type;$/;"	m	struct:config
bad_multiget	config.h	/^  int bad_multiget;$/;"	m	struct:config
bad_multiget	request.h	/^  int bad_multiget;$/;"	m	struct:request
cdf	generate.h	/^  double cdf;$/;"	m	struct:dep_entry
cdf_y	generate.h	/^  int cdf_y[CDF_VALUES];$/;"	m	struct:int_dist
checkError	response.c	/^void checkError(int errorCode, char* key, char* value){$/;"	f
checkExit	stats.c	/^void checkExit(struct config* config) {$/;"	f
cleanUp	loader.c	/^void cleanUp(struct config* config) {$/;"	f
config	config.h	/^struct config {$/;"	s
config	worker.h	/^  struct config* config;$/;"	m	struct:worker	typeref:struct:worker::config
conn	conn.h	/^struct conn {$/;"	s
connection	request.h	/^  struct conn* connection;$/;"	m	struct:request	typeref:struct:request::conn
connections	worker.h	/^  struct conn** connections;$/;"	m	struct:worker	typeref:struct:worker::conn
cpu_num	worker.h	/^  int cpu_num;$/;"	m	struct:worker
createConnection	conn.c	/^struct conn* createConnection(const char* ip_address, int port, int protocol, int naggles) {$/;"	f
createConstantDistribution	generate.c	/^struct int_dist* createConstantDistribution(int constant){$/;"	f
createExponentialDistribution	generate.c	/^struct int_dist* createExponentialDistribution(int meanInterarrival) {$/;"	f
createRequest	request.c	/^struct request* createRequest(int requestType, struct conn* conn, struct worker* worker, char* key, char* value, int type) {$/;"	f
createUniformDistribution	generate.c	/^struct int_dist* createUniformDistribution(int min, int max) {$/;"	f
createWorker	worker.c	/^struct worker* createWorker(struct config* config, int cpuNum) {$/;"	f
createWorkers	worker.c	/^void createWorkers(struct config* config) {$/;"	f
current_request_id	worker.h	/^  int current_request_id;$/;"	m	struct:worker
current_request_uid	config.h	/^  uint32_t current_request_uid;$/;"	m	struct:config
data_type	request.h	/^  char data_type;$/;"	m	struct:request_header
data_type	response.h	/^  char data_type;$/;"	m	struct:response_header
deleteRequest	request.c	/^void deleteRequest(struct request* request) {$/;"	f
deletes	stats.h	/^  int deletes;$/;"	m	struct:memcached_stats
dep_dist	config.h	/^  struct dep_dist* dep_dist;$/;"	m	struct:config	typeref:struct:config::dep_dist
dep_dist	generate.h	/^struct dep_dist {$/;"	s
dep_entries	generate.h	/^  struct dep_entry** dep_entries;$/;"	m	struct:dep_dist	typeref:struct:dep_dist::dep_entry
dep_entry	generate.h	/^struct dep_entry {$/;"	s
event_base	worker.h	/^  struct event_base* event_base;$/;"	m	struct:worker	typeref:struct:worker::event_base
extras	request.h	/^  char* extras;$/;"	m	struct:request
extras_length	request.h	/^  char extras_length;$/;"	m	struct:request_header
extras_length	response.h	/^  char extras_length;$/;"	m	struct:response_header
findQuantile	stats.c	/^double findQuantile(struct stat* stat, double quantile) { $/;"	f
fixed_size	config.h	/^  int fixed_size;$/;"	m	struct:config
fulls	stats.h	/^  int fulls[1000];$/;"	m	struct:stat
generateKeys	generate.c	/^struct key_list* generateKeys(struct config* config) {$/;"	f
generateRequest	generate.c	/^struct request* generateRequest(struct config* config, struct worker* worker) {$/;"	f
generateUID	request.c	/^int generateUID(struct worker* worker) {$/;"	f
genrand	mt19937p.c	/^genrand(struct mt19937p* config)$/;"	f
genrand_int31	mt.c	/^long genrand_int31(void)$/;"	f
genrand_int32	mt.c	/^unsigned long genrand_int32(void)$/;"	f
genrand_real1	mt.c	/^double genrand_real1(void)$/;"	f
genrand_real2	mt.c	/^double genrand_real2(void)$/;"	f
genrand_real3	mt.c	/^double genrand_real3(void)$/;"	f
genrand_res53	mt.c	/^double genrand_res53(void) $/;"	f
getAvg	stats.c	/^double getAvg(struct stat* stat) {$/;"	f
getIntQuantile	generate.c	/^int getIntQuantile(struct int_dist* dist) {$/;"	f
getNextRequest	worker.c	/^struct request* getNextRequest(struct worker* worker) {$/;"	f
getRandomDepEntry	generate.c	/^struct dep_entry* getRandomDepEntry(struct dep_dist* dep_dist, struct worker* worker){$/;"	f
getStdDev	stats.c	/^double getStdDev(struct stat* stat) {$/;"	f
get_frac	config.h	/^  float get_frac;$/;"	m	struct:config
get_size	stats.h	/^  struct stat get_size;$/;"	m	struct:memcached_stats	typeref:struct:memcached_stats::stat
gets	stats.h	/^  int gets;$/;"	m	struct:memcached_stats
global_stats	stats.h	/^struct memcached_stats global_stats;$/;"	v	typeref:struct:memcached_stats
harmonicSum	generate.c	/^double harmonicSum(int size, double alpha){$/;"	f
head	worker.h	/^  int head;$/;"	m	struct:worker
header	request.h	/^  struct request_header header;$/;"	m	struct:request	typeref:struct:request::request_header
hits	stats.h	/^  int hits;$/;"	m	struct:memcached_stats
id	request.h	/^  int id;$/;"	m	struct:request
incr_fix_queue	worker.h	/^  struct request* incr_fix_queue[INCR_FIX_QUEUE_SIZE];$/;"	m	struct:worker	typeref:struct:worker::request
incr_fix_queue_head	worker.h	/^  int incr_fix_queue_head;$/;"	m	struct:worker
incr_fix_queue_tail	worker.h	/^  int incr_fix_queue_tail;$/;"	m	struct:worker
incr_frac	config.h	/^  float incr_frac;$/;"	m	struct:config
incrs	stats.h	/^  int incrs;$/;"	m	struct:memcached_stats
init_by_array	mt.c	/^void init_by_array(unsigned long init_key[], int key_length)$/;"	f
init_genrand	mt.c	/^void init_genrand(unsigned long s)$/;"	f
input_file	config.h	/^  char* input_file;$/;"	m	struct:config
int_dist	generate.h	/^struct int_dist {$/;"	s
interarrival_dist	config.h	/^  struct int_dist* interarrival_dist;$/;"	m	struct:config	typeref:struct:config::int_dist
interarrival_time	worker.h	/^  int interarrival_time;$/;"	m	struct:worker
key	generate.h	/^  char key[251];$/;"	m	struct:dep_entry
key	request.h	/^  char* key;$/;"	m	struct:request
key_length	request.h	/^  char key_length[2];$/;"	m	struct:request_header
key_length	response.h	/^  char key_length[2];$/;"	m	struct:response_header
key_list	config.h	/^  struct key_list* key_list;$/;"	m	struct:config	typeref:struct:config::key_list
key_list	generate.h	/^struct key_list {$/;"	s
key_pop_dist	config.h	/^  struct int_dist* key_pop_dist;$/;"	m	struct:config	typeref:struct:config::int_dist
key_size	request.h	/^  int key_size;$/;"	m	struct:request
keys	generate.h	/^  char** keys;$/;"	m	struct:key_list
keysToPreload	config.h	/^  int keysToPreload;$/;"	m	struct:config
last_time	stats.h	/^  struct timeval last_time;$/;"	m	struct:memcached_stats	typeref:struct:memcached_stats::timeval
last_write_time	worker.h	/^  struct timeval last_write_time;$/;"	m	struct:worker	typeref:struct:worker::timeval
loadAndScaleDepFile	generate.c	/^struct dep_dist* loadAndScaleDepFile(struct config* config) { $/;"	f
loadDepFile	generate.c	/^struct dep_dist* loadDepFile(struct config* config) { $/;"	f
loadDistributionFile	generate.c	/^struct int_dist* loadDistributionFile(char* filename) {$/;"	f
loadServerFile	loader.c	/^void loadServerFile(struct config* config){$/;"	f
lockTest	util.c	/^void lockTest() {$/;"	f
mag01	mt19937p.h	/^	unsigned long mag01[2];$/;"	m	struct:mt19937p
magic	request.h	/^  char magic;$/;"	m	struct:request_header
magic	response.h	/^  char magic;$/;"	m	struct:response_header
main	loader.c	/^int main(int argc, char** argv){$/;"	f
max	stats.h	/^  double max;$/;"	m	struct:stat
memcached_stats	stats.h	/^struct memcached_stats {$/;"	s
micros	stats.h	/^  int micros[10000];$/;"	m	struct:stat
millis	stats.h	/^  int millis[50010];$/;"	m	struct:stat
min	stats.h	/^  double min;$/;"	m	struct:stat
misses	stats.h	/^  int misses;$/;"	m	struct:memcached_stats
mt	mt.c	/^static unsigned long mt[N]; \/* the array for the state vector  *\/$/;"	v	file:
mt	mt19937p.h	/^	unsigned long mt[N];$/;"	m	struct:mt19937p
mt19937p	mt19937p.h	/^struct mt19937p {$/;"	s
mti	mt.c	/^static int mti=N+1; \/* mti==N+1 means mt[N] is not initialized *\/$/;"	v	file:
mti	mt19937p.h	/^	int mti;$/;"	m	struct:mt19937p
multi_gets	stats.h	/^  int multi_gets;$/;"	m	struct:memcached_stats
multiget_dist	config.h	/^  struct int_dist* multiget_dist;$/;"	m	struct:config	typeref:struct:config::int_dist
multiget_frac	config.h	/^  float multiget_frac;$/;"	m	struct:config
multiget_size	config.h	/^  int multiget_size;$/;"	m	struct:config
multigets	stats.h	/^  int multigets;$/;"	m	struct:memcached_stats
myMT19937p	worker.h	/^  struct mt19937p myMT19937p;$/;"	m	struct:worker	typeref:struct:worker::mt19937p
nConnections	worker.h	/^  int nConnections;$/;"	m	struct:worker
n_connections_total	config.h	/^  int n_connections_total;$/;"	m	struct:config
n_cpus	config.h	/^  int n_cpus;$/;"	m	struct:config
n_datagrams	request.h	/^  char n_datagrams[2];$/;"	m	struct:udp_header
n_entries	generate.h	/^  int n_entries;$/;"	m	struct:dep_dist
n_keys	config.h	/^  int n_keys;$/;"	m	struct:config
n_keys	generate.h	/^  int n_keys;$/;"	m	struct:key_list
n_requests	worker.h	/^  int n_requests;$/;"	m	struct:worker
n_servers	config.h	/^  int n_servers;$/;"	m	struct:config
n_workers	config.h	/^  int n_workers;$/;"	m	struct:config
naggles	config.h	/^  int naggles;$/;"	m	struct:config
next_request	request.h	/^  struct request* next_request;$/;"	m	struct:request	typeref:struct:request::request
nslookup	util.c	/^char* nslookup(char* hostname){$/;"	f
opaque	request.h	/^  uint32_t opaque;$/;"	m	struct:request_header
opaque	response.h	/^  uint32_t opaque;$/;"	m	struct:response_header
opcode	request.h	/^  char opcode;$/;"	m	struct:request_header
opcode	response.h	/^  char opcode;$/;"	m	struct:response_header
openTcpSocket	conn.c	/^int openTcpSocket(const char* ipAddress, int port) {$/;"	f
openUdpSocket	conn.c	/^int openUdpSocket(const char* ipAddress, int port) {$/;"	f
ops	stats.h	/^  int ops;$/;"	m	struct:memcached_stats
output_file	config.h	/^  char* output_file;$/;"	m	struct:config
parRandomFunction	util.c	/^int parRandomFunction(struct worker* worker){$/;"	f
parseArgs	loader.c	/^struct config* parseArgs(int argc, char** argv) {$/;"	f
port	conn.h	/^  int port;	$/;"	m	struct:conn
pre_load	config.h	/^  int pre_load;$/;"	m	struct:config
printConfiguration	loader.c	/^void printConfiguration(struct config* config) {$/;"	f
printGlobalStats	stats.c	/^void printGlobalStats(struct config* config) {$/;"	f
printUsage	loader.c	/^void printUsage() {$/;"	f
processResponse	response.c	/^int processResponse(struct response* response, int final, double difftime){$/;"	f
protocol	conn.h	/^  int protocol;$/;"	m	struct:conn
protocol_mode	config.h	/^  int protocol_mode;$/;"	m	struct:config
pushRequest	worker.c	/^int pushRequest(struct worker* worker, struct request* request) {$/;"	f
randomFunction	util.c	/^int randomFunction(){$/;"	f
randomString	generate.c	/^char* randomString(int size){$/;"	f
random_seed	config.h	/^  int random_seed;$/;"	m	struct:config
readBlock	util.c	/^void readBlock(int fd, void* buffer, int readSize) {$/;"	f
readF	worker.c	/^void readF(int* temp){$/;"	f
receiveCallback	worker.c	/^void receiveCallback(int fd, short eventType, void* args) {$/;"	f
receiveResponse	response.c	/^void receiveResponse(struct request* request, double difftime) {$/;"	f
received_warmup_keys	config.h	/^  int received_warmup_keys;$/;"	m	struct:config
received_warmup_keys	worker.h	/^  int received_warmup_keys;$/;"	m	struct:worker
replaces	stats.h	/^  int replaces;$/;"	m	struct:memcached_stats
request	request.h	/^struct request{$/;"	s
request	response.h	/^  struct request* request;$/;"	m	struct:response	typeref:struct:response::request
request_header	request.h	/^struct request_header {$/;"	s
request_id	request.h	/^  char request_id[2];$/;"	m	struct:udp_header
request_queue	worker.h	/^  struct request* request_queue[QUEUE_SIZE];$/;"	m	struct:worker	typeref:struct:worker::request
request_type	request.h	/^  int request_type;$/;"	m	struct:request
requests	stats.h	/^  int requests;$/;"	m	struct:memcached_stats
reserved	request.h	/^  char reserved[2];$/;"	m	struct:request_header
reserved	request.h	/^  char reserved[2];$/;"	m	struct:udp_header
response	response.h	/^struct response {$/;"	s
response_header	response.h	/^  struct response_header response_header;$/;"	m	struct:response	typeref:struct:response::response_header
response_header	response.h	/^  struct response_header response_header;$/;"	m	struct:udp_response_header	typeref:struct:udp_response_header::response_header
response_header	response.h	/^struct response_header {$/;"	s
response_time	stats.h	/^  struct stat response_time;$/;"	m	struct:memcached_stats	typeref:struct:memcached_stats::stat
round	util.c	/^double round(double d) {$/;"	f
rps	config.h	/^  int rps;$/;"	m	struct:config
run_time	config.h	/^  int run_time;$/;"	m	struct:config
s0	stats.h	/^  double s0;$/;"	m	struct:stat
s1	stats.h	/^  double s1;$/;"	m	struct:stat
s2	stats.h	/^  double s2;$/;"	m	struct:stat
scaling_factor	config.h	/^  int scaling_factor;$/;"	m	struct:config
sendCallback	worker.c	/^void sendCallback(int fd, short eventType, void* args) {$/;"	f
sendRequest	request.c	/^void sendRequest(struct request* request) {$/;"	f
send_time	request.h	/^  struct timeval send_time;$/;"	m	struct:request	typeref:struct:request::timeval
sequence_number	request.h	/^  char sequence_number[2];$/;"	m	struct:udp_header
server_file	config.h	/^  char* server_file;$/;"	m	struct:config
server_ip_address	config.h	/^  char* server_ip_address[MAX_SERVERS];$/;"	m	struct:config
server_memory	config.h	/^  int server_memory;$/;"	m	struct:config
server_port	config.h	/^  int server_port[MAX_SERVERS];$/;"	m	struct:config
sets	stats.h	/^  int sets;$/;"	m	struct:memcached_stats
setupLoad	loader.c	/^void setupLoad(struct config* config) {$/;"	f
sgenrand	mt19937p.c	/^sgenrand(unsigned long seed, struct mt19937p* config)$/;"	f
size	generate.h	/^  int size;$/;"	m	struct:dep_entry
sock	conn.h	/^  int sock;$/;"	m	struct:conn
start_time	stats.h	/^struct timeval start_time;$/;"	v	typeref:struct:timeval
stat	stats.h	/^struct stat {$/;"	s
statsLoop	stats.c	/^void statsLoop(struct config* config) {$/;"	f
stats_lock	stats.c	/^pthread_mutex_t stats_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
stats_time	config.h	/^  int stats_time;$/;"	m	struct:config
status	response.h	/^  char status[2];$/;"	m	struct:response_header
tail	worker.h	/^  int tail;$/;"	m	struct:worker
tcpReceiveResponse	response.c	/^int tcpReceiveResponse(struct request* request, int final, double difftime) {$/;"	f
tcpSendRequest	request.c	/^void tcpSendRequest(struct request* request) {$/;"	f
thousands	stats.h	/^  int thousands[1000];$/;"	m	struct:stat
thread	worker.h	/^  pthread_t thread;$/;"	m	struct:worker
timestampTest	util.c	/^void timestampTest() {$/;"	f
timingTests	util.c	/^void timingTests() {$/;"	f
total_body_length	request.h	/^  unsigned char total_body_length[4];$/;"	m	struct:request_header
total_body_length	response.h	/^  char total_body_length[4];$/;"	m	struct:response_header
udpReceiveResponse	response.c	/^int udpReceiveResponse(struct request* request, int final, double difftime) {$/;"	f
udpSendRequest	request.c	/^void udpSendRequest(struct request* request) {$/;"	f
udp_header	request.h	/^struct udp_header {$/;"	s
udp_header	response.h	/^  struct udp_header* udp_header;$/;"	m	struct:udp_response_header	typeref:struct:udp_response_header::udp_header
udp_response_header	response.h	/^struct udp_response_header{$/;"	s
uid	conn.h	/^  int uid;$/;"	m	struct:conn
value	request.h	/^  char* value;$/;"	m	struct:request
value_size	request.h	/^  int value_size;$/;"	m	struct:request
value_size	response.h	/^  int value_size;$/;"	m	struct:response
value_size_dist	config.h	/^  struct int_dist* value_size_dist;$/;"	m	struct:config	typeref:struct:config::int_dist
verbose	loader.c	/^int verbose;$/;"	v
warmup_index	request.h	/^  int warmup_index;$/;"	m	struct:request
warmup_key	worker.h	/^  int warmup_key;$/;"	m	struct:worker
warmup_key_check	worker.h	/^  int warmup_key_check;	$/;"	m	struct:worker
worker	request.h	/^  struct worker* worker;$/;"	m	struct:request	typeref:struct:request::worker
worker	worker.h	/^struct worker {$/;"	s
workerFunction	worker.c	/^void* workerFunction(void* arg) {$/;"	f
workerLoop	worker.c	/^void workerLoop(struct worker* worker) {$/;"	f
workers	config.h	/^  struct worker** workers;$/;"	m	struct:config	typeref:struct:config::worker
writeBlock	util.c	/^void writeBlock(int fd, void* buffer, int writeSize) {$/;"	f
writeF	worker.c	/^void writeF(int temp){$/;"	f
zynga	config.h	/^  int zynga;$/;"	m	struct:config
